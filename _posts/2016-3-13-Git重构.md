# Git 重构
在日常开发中，由于提交疏忽导致文件没有提交，或者提交后由于各种原因（需求变更)导致再次反复提交。总之，当我们想要将本地版本库和服务端版本库同步的时候，本地提交历史中各种无用或者重复的提交。不同于svn的，git 提供了多种“悔棋”的工具

## 单步重构
单步重构主要适用场景是当我们进行一次提交后，马上发现这一次的提交遗忘了文件，或者写错了message的时候，这时候使用

	$ git commit --amend  

可以将本次提交追加到上一次的提交中。添加 `-m` 参数，后面可以直接添加修改后的 `message` ,反之会调起编辑器(默认VI)提示用户编辑 `message` 。

此命令相当于撤销上一次操作到缓冲区，然后将当前`缓冲区`内容作为快照提交。结果就好像就对最后一次提交的追加，修改。

	$ git reset --soft HEAD
	$ git add .
	$ git commit -m "xxxx"



## 多步连续重构
多步连续重构主要使用场景是在一系列提交后，发现从某个提交到最新的提交可以合成一个完成的提交，这个时候可以使用`连续多部重构`

	$ git reset --soft commitID 
	$ git commit -m "xxxx"
	

## 挑拣重构
挑拣重构主要使用场景是在一系列的提交后，对于当前的提交记录中，仅仅需要保持个别的记录，其余提交需要舍弃。这个时候可以使用`挑拣重构`

	 $ git cherry-pick 

git cherry-pick 的含义是从众多的提交中挑选出一个提交拼接到当前的工作分支中，该命令需要一个提交ID的参数，操作过程相当于将该提交导出为补丁文件（两个拼接节点直接的差异补丁），然后在当前`HEAD`上重新提交，形成内容和提交说明一致的一个提交节点。

![cherry-pick](https://github.com/Ambtion/ambtion.github.io/blob/master/imageSource/git/Git-CherryPiker.png?raw=ture)

上图中罗列了重构前和重构后的 git 提交历史结构。

重构过程中其实要求的是在 B 接点处将 D 和 E 节点挑拣出来。

整个过程如下：

1.HEAD指向 B 节点 （此时HEAD处于分离状态）
	
	$ git checkout B

2.挑拣 D 补存到 B 节点后， 挑拣 F 补存到 D 节点后
	
	$ git cherry-pick D
	$ git cherry-pick F




## 变基重构



