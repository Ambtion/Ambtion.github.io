# 前言

[上一章](http://ambtion.github.io/2020/Swift%E8%90%BD%E5%9C%B0%E6%8E%A2%E7%B4%A2/)讲述选择Swift语言的原因;尽管我们可以选择Swift开发一个新的项目，然后对于国内目前大多数IOS开发者，目前基本工作在Objective-c项目上；所以如何从一个Objective-c项目切换到Swift开发成了重中之重；这也是本章探索的主题

如何将工程转换为Swfit，苹果[文档](Migrating Your Objective-C Code to Swift](https://developer.apple.com/documentation/swift/migrating_your_objective-c_code_to_swif)给出了建议，逐个文件转换，具体视项目复杂度而定；简单又复杂的建议！！！

不过开发中，我们可以注意一下几点 : 

## 2个原则

1. Swift Class 不能被Objective-C 继承；苹果在[Migrating Your Objective-C Code to Swift](https://developer.apple.com/documentation/swift/migrating_your_objective-c_code_to_swift)中明确指名这点；这意味这要转换为Swift 代码的Class不能在Objective-C中存在子类 

2. Swift 无法直接调用C++；这一特性意味项目中涉及C++调用的Class不能使用转换为Swift

## 3个Case

### Case 1 ：Objective-C 与 Swift 在同一Target中

#### 1. Swift 调用 Objective-C

![](https://github.com/Ambtion/ambtion.github.io/blob/master/imageSource/Swift/swift-Objective-C.png?raw=ture)


上图中的**<ProjectName>-Bridging-Head.h** 文件的作用就是同一个Target下，Swift 包含 Objective-C 文件；在**<ProjectName>-Bridging-Head.h** @import Objective-C头文件即可；

**<ProjectName>-Bridging-Head.h** 是在工程中创建Swift文件的时候，Xcode提示自动生成的问题；当然也可以手动添加，记得保持Target BuildingSetting 中 **Objective-C Bridging Header** 内容和新创建的文件一致即可


#### 2. Objective-C 调用 Swift

![](https://github.com/Ambtion/ambtion.github.io/blob/master/imageSource/Swift/swift-generateHead.png?raw=ture)

编译器会在/Build folder under /DerivedData directory 目录下生成<ProductName>-Swift.h 文件，直接包含文件即可

![](https://github.com/Ambtion/ambtion.github.io/blob/master/imageSource/Swift/swiftFile.png?raw=ture)

![](https://github.com/Ambtion/ambtion.github.io/blob/master/imageSource/Swift/swiftGenerateHead.png?raw=ture)

对于**<ProductName>-Swift.h** 文件，也可以通过脚本copy到自定义目录下，调用时候保证Target Setting **Header Search Paths**对应即可

### Case 2： Swift 静态库

#### 1. Objective-C 调用 Swift 静态库

1. @obj 或者 继承NSObject保证Class可以被Objective C 文件获取
2. 使用脚本将编译器生成的**<ProductName>-Swift.h**头文件导入到静态库目录下。
3. 工程中添加静态库，设置头文件路径，import **<ProductName>-Swift.h**即可使用
 
#### 2. Swift 调用 Swift 静态库

1. 设置**Header Search Paths**
2. 添加静态库
3. import modelName modelName为静态库名称

### Case 3: Objective-C静态库

#### 1：Swift 调用Objective-C静态库

**Bridging-Header** 对用同一Target调用，可以帮忙Swift调用Objective-C;然而调用Objective-C静态库，则需要创建使用**.modulemap**文件暴露Objective-C头文件；

modulemap是一种数形描述的头文件包含方式；其中一个最大的优点就是可以提高编译速度；假设一个工程中有N个文件，M个头文件；使用include，编译器需要执行N * M处理；使用modulemap 则需要N + M；主要原因是modulemap 仅仅编译一次，在被引用时，编译器直接加载module,并将其APi整个工程可见；具体细节原理可看[这篇文章](https://clang.llvm.org/docs/Modules.html#introduction)、[Swift 关于 module.modulemap使用](https://www.jianshu.com/p/ce49d8f32f77)、

* Framework 创建Modulels ：**build settings 设置Defines Module为YES
 **，编译项目就会生成module 文件；Swift 直接import modules即可调用
*  Static Library创建Modulel ：
	1：手动创建modulemap文件 ，**build settings 设置Defines Module为YES，Module Map File 路径为添加文件**
	2：保证Module.modulemap添加到Copy Files中
	3:  添加静态库，直接import ModelName ModelName为静态库名称

### 2: Objective-C 调用Objective-C静态库
     1. 设置**Header Search Paths**
	2. 添加静态库
	3. import ModelName ModelName为静态库名称



## 参看文献：

[Understanding Objective-C Modules](https://samsymons.com/blog/understanding-objective-c-modules/)
[Swift static library in Objective-C](https://paul-samuels.com/blog/2018/01/14/swift-static-library-in-objective-c//)
[clang 12 document](https://clang.llvm.org/docs/Modules.html#introduction)
[Swift 关于 module.modulemap 使用](https://www.jianshu.com/p/ce49d8f32f77)













 
		


	
	









