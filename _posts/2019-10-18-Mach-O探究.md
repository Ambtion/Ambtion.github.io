#Mach-O探究

OS的内核是苹果在Mach，BSD开发基础上开发出来的内核;XNU中复制了很多BSD的能力	(网络框架，VFS)，同时XNU在此基础上也扩展了很多苹果自己的能力(内核扩展kext，I/O Kit);


## OS可执行文件
类似于Linux,OS X 内核也包含了针对各种支持的可执行格式的专用处理程序。Linux将这些处理程序称为“二进制格式”，而OS X则称为execsw;
功能相识，但是Linux却强大很多，主要因为Linux可以在内核模块动态注册处理程序；而Mac则是内核硬编码支持，如要注册需重新编译内核；以下是苹果开源OS内核代码（IOS不开源）

	 * Our image activator table; 
	 * this is the table of the image types we are
	 * capable of loading. We list them in order of
	 * preference to ensure the
	 * fastest image load speed.
	 *
	 * XXX hardcoded, for now; should use linker sets
	 
	struct execsw {
	
		int (*ex_imgact)(struct image_params *);
	
		const char *ex_name;
	} execsw[] = {
		{ exec_mach_imgact,		"Mach-o Binary" },
		{ exec_fat_imgact,		"Fat Binary" },
		{ exec_shell_imgact,	"Interpreter Script" },
		{ NULL, NULL}
	};
	

支持格式写死在硬编码中，原生Mach-O（NextSTEP遗物）、Fat 二进制格式（多个架包集合）、脚本语言

## Mach-O结构
使用MachOView查看通过Lipo提炼的Armv7结构如下图：

![blockChain](https://github.com/Ambtion/ambtion.github.io/blob/master/imageSource/MachO/MachOView.png?raw=ture)


### Mach Header

Mach-O 具有固定格式的文件头mach\_header；mach\_header 的数据结构在 <mach-o/loader.h> 头文件
	

	struct mach_header {
	uint32_t	magic;		/* mach magic number identifier */
	cpu_type_t	cputype;	/* cpu specifier */
	cpu_subtype_t	cpusubtype;	/* machine specifier */
	uint32_t	filetype;	/* type of file */
	uint32_t	ncmds;		/* number of load commands */
	uint32_t	sizeofcmds;	/* the size of all the load commands */
	uint32_t	flags;		/* flags */
	};
	
文件的开头是一个魔数，用于判断二进制文件是32位还是64位；其后的cpu\_type\_t 和 cpu\_subtype\_t确保当前二进制适合并且可以在当前架构下运行；

由于 Mach-O 支持多种类型文件，所以此处引入了 filetype 字段来标明，这些文件类型定义在 loader.h 文件中同样可以找到;
		
	#define    MH_OBJECT    0x1        /* Target 文件：编译器对源码编译后得到的中间结果 */

	#define    MH_EXECUTE    0x2        /* 可执行二进制文件 */
	
	#define    MH_FVMLIB    0x3        /* VM 共享库文件 */
	
	#define    MH_CORE        0x4        /* Core 文件，一般在 App Crash 产生 */
	
	#define    MH_PRELOAD    0x5        /* preloaded executable file */
	
	#define    MH_DYLIB    0x6       	 /* 动态库 */
	
	#define    MH_DYLINKER    0x7        /* 动态连接器 /usr/lib/dyld */
	
	#define    MH_BUNDLE    0x8        /* 非独立的二进制文件，往往通过 gcc-bundle 生成 */
	
	#define    MH_DYLIB_STUB    0x9        /* 静态链接文*/
	
	#define    MH_DSYM        0xa        /* 符号文件以及调试信息，gcc -g 生成 */
	#define    MH_KEXT_BUNDLE    0xb        /* x86_64 内核扩展 */

另外在 loader.h 中还可以找到 flags 中所取值的全部定义，这里只介绍常用的：
		
	#define    MH_NOUNDEFS    0x1        /* Target 文件中没有带未定义的符号，常为静态二进制文件 */
	#define MH_SPLIT_SEGS    0x20  /* Target 文件中的只读 Segment 和可读写 Segment 分开  */
	#define MH_TWOLEVEL    0x80        /* 该 Image 使用二级命名空间(two name space binding)绑定方案 */
	#define MH_FORCE_FLAT    0x100 /* 使用扁平命名空间(flat name space binding)绑定（与 MH_TWOLEVEL 互斥） */
	#define MH_WEAK_DEFINES    0x8000 /* 二进制文件使用了弱符号 */
	#define MH_BINDS_TO_WEAK 0x10000 /* 二进制文件链接了弱符号 */
	#define MH_ALLOW_STACK_EXECUTION 0x20000/* 允许 Stack 可执行 */
	#define    MH_PIE 0x200000  /* 对可执行的文件类型启用地址空间 layout 随机化 */
	#define MH_NO_HEAP_EXECUTION 0x1000000 /* 将 Heap 标记为不可执行，可防止 heap spray 攻击 */
	
ncmds和sizeofcmds主要用于解析加载命令；

### Mach-O加载

紧随文件头的是Load Commonds,包含非常详细的“加载指令”，清晰的指导如何设置并加装二进制数据；这些命令主要有两部分，一部分是内核加载器直接使用，负责新进程的虚拟内存分配设置，创建主线程，以及处理代码签名加密工作；剩余指令则是由动态链接器处理完成;

#### LC_SEGMENT

LC_SEGMENT是最主要的加载命令，这条命令指导内核如何设置新运行的进程的内存空间。这些"段"直接从Mach-O二进制文件中加载到内存；
每一条LC_SEGMENT命令都提供了段布局的所有必要细节信息，如下表：

参数 | 用途
segment | load_segment
vmaddr	 | 描述的段的虚拟物理地址
vmsize	 | 段分配的虚拟物理地址大小
fileoff | 段在文件中偏移
fileSize | 段在文件中大小
maxprot | 段页面的内存包含（4=r,2=w,1=x）主要用于防止代码注入
intport | 段页面初始内存包含
nsets | 段中区的数量
flag | 杂选项标志位


通过LC_SEGMENT,设置进程虚拟内存的过程变成了遵循LC_SEGMENT命令的简单操作；对于每一个段，将二进制中fileoffset开始，长度filesize的内容加载到vmaddr开始，vmsize长度的内容中；



## Mach-O运行













