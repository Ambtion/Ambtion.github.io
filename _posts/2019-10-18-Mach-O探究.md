#Mach-O探究

OS的内核是苹果在Mach，BSD开发基础上开发出来的内核;XNU中复制了很多BSD的能力	(网络框架，VFS)，同时XNU在此基础上也扩展了很多苹果自己的能力(内核扩展kext，I/O Kit);


## OS可执行文件
类似于Linux,OS X 内核也包含了针对各种支持的可执行格式的专用处理程序。Linux将这些处理程序称为“二进制格式”，而OS X则称为execsw;
功能相识，但是Linux却强大很多，主要因为Linux可以在内核模块动态注册处理程序；而Mac则是内核硬编码支持，如要注册需重新编译内核；以下是苹果开源OS内核代码（IOS不开源）

	 * Our image activator table; 
	 * this is the table of the image types we are
	 * capable of loading. We list them in order of
	 * preference to ensure the
	 * fastest image load speed.
	 *
	 * XXX hardcoded, for now; should use linker sets
	 
	struct execsw {
	
		int (*ex_imgact)(struct image_params *);
	
		const char *ex_name;
	} execsw[] = {
		{ exec_mach_imgact,		"Mach-o Binary" },
		{ exec_fat_imgact,		"Fat Binary" },
		{ exec_shell_imgact,	"Interpreter Script" },
		{ NULL, NULL}
	};
	

支持格式写死在硬编码中，原生Mach-O（NextSTEP遗物）、Fat 二进制格式（多个架包集合）、脚本语言

## Mach-O结构
使用MachOView查看通过Lipo提炼的Armv7结构如下图：



### Fat Header
Mach-O 具有固定格式的文件头mach_header；mach_header 的数据结构在 <mach-o/loader.h> 头文件
	

	struct mach_header {
	uint32_t	magic;		/* mach magic number identifier */
	cpu_type_t	cputype;	/* cpu specifier */
	cpu_subtype_t	cpusubtype;	/* machine specifier */
	uint32_t	filetype;	/* type of file */
	uint32_t	ncmds;		/* number of load commands */
	uint32_t	sizeofcmds;	/* the size of all the load commands */
	uint32_t	flags;		/* flags */
	};
	
文件的开头是一个魔数，用于判断二进制文件是32位还是64位；其后的cpu_type_t和cpu_subtype_t确保当前二进制适合并且可以在当前架构下运行；之后的FileType定义文件的类型；这个字段已宏定义的方式保证在<mach-o/loader.h>中；
	Mach-O的主要功能用于加载命令（load_commond），加载命令跟谁头文件之后；ncmds和sizeofcmds解析加载命令；
	
	
	
	
## Mach-O加载


## Mach-O运行













